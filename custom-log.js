// Generated by CoffeeScript 2.5.1
(function () {
  // custom-log.coffee - A tiny console.log wrapper, written in Coffeescript.
  // MIT License
  // Copyright (c) 2015 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  "use strict";

  var CUSTOM_LOG,
      customLog,
      forceObject,
      instanceOf,
      intoArray,
      hasProp = {}.hasOwnProperty;
  CUSTOM_LOG = 'custom-log: '; // taken from types.js

  intoArray = function (args) {
    if (args.length < 2) {
      if (typeof args[0] === 'string') {
        args = args.join('').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ').split(' ');
      } else if (typeof args[0] === 'object' && args[0] instanceof Array) {
        args = args[0];
      }
    }

    return args;
  };

  instanceOf = function (type, value) {
    return value instanceof type;
  };

  forceObject = function (value) {
    if (typeof value === 'object' && value !== null && !instanceOf(Boolean, value) && !instanceOf(Number, value) && !instanceOf(Array, value) && !instanceOf(RegExp, value) && !instanceOf(Date, value)) {
      return value;
    } else {
      return {};
    }
  }; // prefixes is primarily for creating log.anyPrefix methods


  customLog = function (prefixes, settings) {
    var Log, enact, level, log, logInstance, prefix, prefixMsg;

    if (typeof prefixes === 'string') {
      // prefixes as string is for a only single log function with prefix
      prefixMsg = prefixes;
    }

    prefixes = forceObject(prefixes);
    settings = forceObject(settings);
    Log = class Log {
      constructor(level, prefix) {
        var prop, ref, value;
        this.disable = this.disable.bind(this);
        this.enable = this.enable.bind(this);
        this.enabled = true;
        this.level = level || 'log';
        this.prefix = prefix || '';

        this.log = (...args) => {
          var message;

          if (this.enabled) {
            prefix = typeof this.prefix === 'function' ? this.prefix(...args) : this.prefix;
            message = this.prefix ? [prefix].concat(...args) : args;
            return console.log.apply(console, message);
          }
        };

        ref = this;

        for (prop in ref) {
          if (!hasProp.call(ref, prop)) continue;
          value = ref[prop];

          if (prop !== 'log') {
            this.log[prop] = value;
          }
        }
      }

      disable() {
        this.enabled = false;

        if (!settings.silentDisable) {
          return console.log(CUSTOM_LOG + '.' + this.level + ' is disabled');
        }
      }

      enable() {
        this.enabled = true;

        if (!settings.silentEnable) {
          return console.log(CUSTOM_LOG + '.' + this.level + ' is enabled');
        }
      }

    }; // end of Log
    // create a default log right away

    logInstance = new Log('log', prefixMsg);
    log = logInstance.log; // abstract function for enable and disable

    enact = function (method, ...levels) {
      var i, len, level, results;
      levels = intoArray(levels);
      results = [];

      for (i = 0, len = levels.length; i < len; i++) {
        level = levels[i];

        if (level === 'log') {
          results.push(logInstance[method]());
        } else if (log[level] != null) {
          results.push(log[level][method]());
        } else {
          results.push(void 0);
        }
      }

      return results;
    };

    log.enable = function (...args) {
      return enact('enable', ...args);
    };

    log.disable = function (...args) {
      return enact('disable', ...args);
    }; // create log levels/instances from prefixes object


    for (level in prefixes) {
      prefix = prefixes[level];

      (function (level, prefix) {
        switch (level) {
          // allow the default log to have a prefix
          case 'log':
            return logInstance.prefix = prefix;

          default:
            return log[level] = new Log(level, prefix).log;
        }
      })(level, prefix);
    }

    return log;
  }; // end of customLog


  if (typeof define !== "undefined" && define !== null && 'function' === typeof define && define.amd) {
    define('customLog', [], function () {
      return customLog;
    });
  } else if (typeof module !== 'undefined') {
    module.exports = customLog;
  } else if (typeof window !== 'undefined') {
    window.customLog = customLog;
  }
}).call(this);