"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  // custom-log.coffee - A tiny console.log wrapper, written in Coffeescript.
  // MIT License
  // Copyright (c) 2015 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  "use strict";

  var _customLog, intoArray; // taken from types.js


  intoArray = function intoArray(args) {
    if (args.length < 2) {
      if (typeof args[0] === 'string') {
        args = args.join('').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ').split(' ');
      } else if (_typeof(args[0]) === 'object' && args[0] instanceof Array) {
        args = args[0];
      }
    }

    return args;
  };

  _customLog = function customLog(init) {
    var CUSTOM_LOG, Log, enact, level, log, logInstance, prefix, prefixMsg;
    CUSTOM_LOG = 'custom-log: ';

    Log = /*#__PURE__*/function () {
      function Log(level, prefix) {
        var _arguments = arguments,
            _this = this;

        _classCallCheck(this, Log);

        var prop, ref, value;
        this.disable = this.disable.bind(this);
        this.enable = this.enable.bind(this); // this was a bad idea, it sucks and will be removed..

        this.assert = this.assert.bind(this);
        this.enabled = true;
        this.level = level || 'log';
        this.prefix = prefix || '';

        this.log = function () {
          var message;

          if (_this.enabled) {
            message = _arguments;

            if (_this.prefix) {
              var _ref;

              message = (_ref = [_this.prefix]).concat.apply(_ref, _toConsumableArray(_arguments));
            }

            return console.log.apply(console, message);
          }
        };

        ref = this;

        for (prop in ref) {
          value = ref[prop];

          if (this.hasOwnProperty(prop) && prop !== 'log') {
            this.log[prop] = value;
          }
        }
      }

      _createClass(Log, [{
        key: "disable",
        value: function disable() {
          this.enabled = false;
          return console.log(CUSTOM_LOG + '.' + this.level + ' is disabled');
        }
      }, {
        key: "enable",
        value: function enable() {
          this.enabled = true;
          return console.log(CUSTOM_LOG + '.' + this.level + ' is enabled');
        }
      }, {
        key: "assert",
        value: function assert(predicate) {
          var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

          if (typeof predicate === 'string') {
            description = predicate;
          }

          if (description) {
            description = '(' + description + ') == ';
          }

          if (typeof predicate === 'string') {
            predicate = eval(predicate);
          }

          if (predicate) {
            predicate = 'TRUE';
          } else {
            predicate = 'FALSE';
          }

          return this.log('\n\t' + _customLog.assertMessage + description + predicate + '\n');
        }
      }]);

      return Log;
    }();

    if (typeof init === 'string') {
      // end of Log
      prefixMsg = init;
    }

    logInstance = new Log('log', prefixMsg);
    log = logInstance.log; // one function for enable and disable

    enact = function enact(method) {
      for (var _len = arguments.length, levels = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        levels[_key - 1] = arguments[_key];
      }

      var i, len, level, results;
      levels = intoArray(levels);
      results = [];

      for (i = 0, len = levels.length; i < len; i++) {
        level = levels[i];

        if (level === 'log') {
          results.push(logInstance[method]());
        } else if (log[level] != null) {
          results.push(log[level][method]());
        } else {
          results.push(void 0);
        }
      }

      return results;
    };

    log.enable = function () {
      return enact.apply(void 0, ['enable'].concat(Array.prototype.slice.call(arguments)));
    };

    log.disable = function () {
      return enact.apply(void 0, ['disable'].concat(Array.prototype.slice.call(arguments)));
    };

    if (_typeof(init) === 'object') {
      for (level in init) {
        prefix = init[level];

        (function (level, prefix) {
          switch (level) {
            case 'log':
              return logInstance.prefix = prefix;

            case 'assert':
              return _customLog.assertMessage = prefix;

            default:
              return log[level] = new Log(level, prefix).log;
          }
        })(level, prefix);
      }
    }

    return log;
  };

  _customLog.assertMessage = 'Assert: '; // end of customLog

  if (typeof define !== "undefined" && define !== null && 'function' === typeof define && define.amd) {
    define('customLog', [], function () {
      return _customLog;
    });
  } else if (typeof module !== 'undefined') {
    module.exports = _customLog;
  } else if (typeof window !== 'undefined') {
    window.customLog = _customLog;
  }
}).call(void 0);