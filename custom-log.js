"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Generated by CoffeeScript 2.5.1
(function () {
  // custom-log.coffee - A tiny console.log wrapper, written in Coffeescript.
  // MIT License
  // Copyright (c) 2015 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  "use strict";

  var CUSTOM_LOG,
      customLog,
      forceObject,
      instanceOf,
      intoArray,
      hasProp = {}.hasOwnProperty;
  CUSTOM_LOG = 'custom-log: '; // taken from types.js

  intoArray = function intoArray(args) {
    if (args.length < 2) {
      if (typeof args[0] === 'string') {
        args = args.join('').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ').split(' ');
      } else if (_typeof(args[0]) === 'object' && args[0] instanceof Array) {
        args = args[0];
      }
    }

    return args;
  };

  instanceOf = function instanceOf(type, value) {
    return value instanceof type;
  };

  forceObject = function forceObject(value) {
    if (_typeof(value) === 'object' && value !== null && !instanceOf(Boolean, value) && !instanceOf(Number, value) && !instanceOf(Array, value) && !instanceOf(RegExp, value) && !instanceOf(Date, value)) {
      return value;
    } else {
      return {};
    }
  }; // prefixes is primarily for creating log.anyPrefix methods


  customLog = function customLog(prefixes, settings) {
    var Log, enact, level, log, logInstance, prefix, prefixMsg;

    if (typeof prefixes === 'string') {
      // prefixes as string is for a only single log function with prefix
      prefixMsg = prefixes;
    }

    prefixes = forceObject(prefixes);
    settings = forceObject(settings);

    Log = /*#__PURE__*/function () {
      function Log(level, prefix) {
        var _this = this;

        _classCallCheck(this, Log);

        var prop, ref, value;
        this.disable = this.disable.bind(this);
        this.enable = this.enable.bind(this);
        this.enabled = true;
        this.level = level || 'log';
        this.prefix = prefix || '';

        this.log = function () {
          var message;

          if (_this.enabled) {
            var _ref;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            prefix = typeof _this.prefix === 'function' ? _this.prefix.apply(_this, args) : _this.prefix;
            message = _this.prefix ? (_ref = [prefix]).concat.apply(_ref, args) : args;
            return console.log.apply(console, message);
          }
        };

        ref = this;

        for (prop in ref) {
          if (!hasProp.call(ref, prop)) continue;
          value = ref[prop];

          if (prop !== 'log') {
            this.log[prop] = value;
          }
        }
      }

      _createClass(Log, [{
        key: "disable",
        value: function disable() {
          this.enabled = false;

          if (!settings.silentDisable) {
            return console.log(CUSTOM_LOG + '.' + this.level + ' is disabled');
          }
        }
      }, {
        key: "enable",
        value: function enable() {
          this.enabled = true;

          if (!settings.silentEnable) {
            return console.log(CUSTOM_LOG + '.' + this.level + ' is enabled');
          }
        }
      }]);

      return Log;
    }(); // end of Log
    // create a default log right away


    logInstance = new Log('log', prefixMsg);
    log = logInstance.log; // abstract function for enable and disable

    enact = function enact(method) {
      for (var _len2 = arguments.length, levels = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        levels[_key2 - 1] = arguments[_key2];
      }

      var i, len, level, results;
      levels = intoArray(levels);
      results = [];

      for (i = 0, len = levels.length; i < len; i++) {
        level = levels[i];

        if (level === 'log') {
          results.push(logInstance[method]());
        } else if (log[level] != null) {
          results.push(log[level][method]());
        } else {
          results.push(void 0);
        }
      }

      return results;
    };

    log.enable = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return enact.apply(void 0, ['enable'].concat(args));
    };

    log.disable = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return enact.apply(void 0, ['disable'].concat(args));
    }; // create log levels/instances from prefixes object


    for (level in prefixes) {
      prefix = prefixes[level];

      (function (level, prefix) {
        switch (level) {
          // allow the default log to have a prefix
          case 'log':
            return logInstance.prefix = prefix;

          default:
            return log[level] = new Log(level, prefix).log;
        }
      })(level, prefix);
    }

    return log;
  }; // end of customLog


  if (typeof define !== "undefined" && define !== null && 'function' === typeof define && define.amd) {
    define('customLog', [], function () {
      return customLog;
    });
  } else if (typeof module !== 'undefined') {
    module.exports = customLog;
  } else if (typeof window !== 'undefined') {
    window.customLog = customLog;
  }
}).call(void 0);